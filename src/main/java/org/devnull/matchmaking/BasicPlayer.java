package org.devnull.matchmaking;

//import static org.devnull.matchmaking.CommonMacros.*;

import java.util.Comparator;

/**
 * <p>
 * Representation of a player.
 * </p>
 * <p>
 * As indicated in the challenge description, feel free to augment the BasicPlayer
 * class in any way that you feel will improve your final matchmaking solution.
 * <strong>Do NOT remove the name, wins, or losses fields.</strong> Also note
 * that if you make any of these changes, you are responsible for updating the
 * {@link SampleData} such that it provides a useful data set to exercise your
 * solution.
 * </p>
 */
public class BasicPlayer implements PlayerInterface, java.io.Serializable {

    /** Generated by the serialver utility */
    //TODO: private static final long serialVersionUID = 6767373972869040494L;

    //public static final PlayerProperties<BasicPlayer> PLAYER_PROPERTIES = pps(
    //    null,
    //    pp("name", BasicPlayer::getName),
    //    pp("wins", BasicPlayer::getWins),
    //    pp("losses", BasicPlayer::getLosses),
    //    pp("winRate", BasicPlayer::getWinRate),
    //    pp("battlesFought", BasicPlayer::getBattlesFought)
    //);

    /**
     * A comparator that orders {@code BasicPlayer} objects by name.
     * Similar to {@link java.lang.String#CASE_INSENSITIVE_ORDER}.
     */
    public static final Comparator<BasicPlayer> NAME_COMPARATOR = new NameComparator();

    private static final class NameComparator implements Comparator<BasicPlayer>, java.io.Serializable {

        /** Generated by the serialver utility */
        //TODO: private static final long serialVersionUID = 6662658530147184337L;

        @Override
        public final int compare(final BasicPlayer p1, final BasicPlayer p2) {
            return p1.name.compareTo(p2.name);
        }
    }



    private final String name;
    private final int wins;
    private final int losses;

    public BasicPlayer(final String name, final int wins, final int losses) {
        // The same as java.util.Objects#requireNonNull(T)
        if (name == null) throw new NullPointerException();
        if (wins < 0) throw new IllegalArgumentException(name + " (wins: " + wins + ")");
        if (losses < 0) throw new IllegalArgumentException(name + " (losses: " + losses + ")");
        this.name = name;
        this.wins = wins;
        this.losses = losses;
    }

    //@Override
    //public PlayerProperties<PlayerInterface> getPlayerProperty() {
    //    return null;
    //}

    // Interview Note: Java Feature - Covariant Return Type
    @Override
    public BasicPlayer getRealPlayer() {
        return this;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public int getWins() {
        return this.wins;
    }

    @Override
    public int getLosses() {
        return this.losses;
    }

    @Override
    public int hashCode() {
        // The same as java.util.Objects#hash(Object...)
        /* (This should be used if the fields are `long`s instead of `int`s)
        return
            (
                (
                    (1 * 31) + this.name.hashCode()
                ) * 31 + ((int)(this.wins ^ (this.wins >>> 32)))
            ) * 31 + ((int)(this.losses ^ (this.losses >>> 32)));
        */
        return
            (
                (
                    (1 * 31) + this.name.hashCode()
                ) * 31 + this.wins
            ) * 31 + this.losses;
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        // Note: Do NOT use "instanceof" here
        // Java equality sucks, let's use Scala!
        // See: http://stackoverflow.com/q/12239344/142239
        if (obj.getClass() != BasicPlayer.class) return false;
        final BasicPlayer p = (BasicPlayer) obj;
        return this.name.equals(p.name)
            && this.wins == p.wins
            && this.losses == p.losses;
    }

    @Override
    public String toString() {
        // TODO: Should use Apache Commons StringEscapeUtils to escape this.name here,
        //       but let's assume there are no special characters for simplicity.
        return new StringBuilder("[BasicPlayer: \"name\": \"")
            .append(this.name)
            .append("\", \"wins\": ")
            .append(this.wins)
            .append(", \"losses\": ")
            .append(this.losses)
            .append("]")
            .toString();
    }


    public static final void main(final String... args) {
        // TODO: Test construction exceptions
        final BasicPlayer kenji_1a = new BasicPlayer("Kenji", 321, 123);
        final BasicPlayer kenji_1b = new BasicPlayer("Kenji", 321, 123);
        final BasicPlayer kenji_2 = new BasicPlayer("kenji", 321, 123);
        final BasicPlayer kenji_3 = new BasicPlayer("Kenji", 432, 123);
        final BasicPlayer kenji_4 = new BasicPlayer("Kenji", 321, 234);
        assert kenji_1a.hashCode() == kenji_1b.hashCode();
        assert kenji_1a.hashCode() != kenji_2.hashCode();
        assert kenji_1a.hashCode() != kenji_3.hashCode();
        assert kenji_1a.hashCode() != kenji_4.hashCode();
        assert kenji_1a.equals(kenji_1b);
        assert !kenji_1a.equals(kenji_2);
        assert !kenji_1a.equals(kenji_3);
        assert !kenji_1a.equals(kenji_4);
        assert kenji_1a.toString().equals("[BasicPlayer: \"name\": \"Kenji\", \"wins\": 321, \"losses\": 123]");
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_1a) == 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_1b) == 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_2) < 0;
        assert NAME_COMPARATOR.compare(kenji_2, kenji_1a) > 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_3) == 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_4) == 0;
    }
}
