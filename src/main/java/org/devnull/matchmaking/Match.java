package org.devnull.matchmaking;

import java.util.Set;
import java.util.function.Function;

/**
 * <p>
 * Representation of a match.
 * </p>
 * <p>
 * Not much is changed in {@code Match}. Since this is a data-based class,
 * methods from {@link java.lang.Object} are overridden, and it is modified to
 * implement {@link java.io.Serializable}.
 * </p>
 * <p>
 * It is better to make it an interface, {@code Match}, and a class
 * {@code BasicMatch}. Since eliminating concrete classes in all method
 * signatures is an important goal of the design.
 * </p>
 */
public class Match implements java.io.Serializable {

    /** Generated by the serialver utility */
    //TODO: private static final long serialVersionUID = -5262879256745620081L;

    // Interview Note: Java Feature - Streams
    // Interview Note: Java Feature - Lambda Expressions
    // Interview Note: Java Feature - Method References
    private static String stringify(final Set<Player> team) {
        // TODO: Should use Apache Commons StringEscapeUtils to escape this.name here,
        //       but let's assume there are no special characters for simplicity.
        final Function<Player, String> mapper = (player) ->
            new StringBuilder().append('"').append(player.getName()).append('"').toString();
        final Iterable<String> iterable = team.stream().map(mapper)::iterator;
        return new StringBuilder().append('[').append(String.join(", ", iterable)).append(']').toString();
    }



    private final Set<Player> team1;
    private final Set<Player> team2;

    public Match(final Set<Player> team1, final Set<Player> team2) {
        // The same as java.util.Objects#requireNonNull(T)
        if (team1 == null) throw new NullPointerException();
        if (team2 == null) throw new NullPointerException();
        if (team1.size() != team2.size()) {
            throw new IllegalArgumentException("team1: " + stringify(team1) + ", team2: " + stringify(team2));
        }
        this.team1 = team1;
        this.team2 = team2;
    }



    @Override
    public int hashCode() {
        // The same as java.util.Objects#hash(Object...)
        return
            (
                (1 * 31) + this.team1.hashCode()
            ) * 31 + this.team2.hashCode();
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        // Note: Do NOT use "instanceof" here
        // Java equality sucks, let's use Scala!
        // See: http://stackoverflow.com/q/12239344/142239
        if (obj.getClass() != Match.class) return false;
        final Match m = (Match) obj;
        return this.team1.equals(m.team1)
            && this.team2.equals(m.team2);
    }

    @Override
    public String toString() {
        return new StringBuilder("[Match: \"team1\": ")
            .append(stringify(this.team1))
            .append(", \"team2\": ")
            .append(stringify(this.team2))
            .append("]")
            .toString();
    }



    public Set<Player> getTeam1() {
        return this.team1;
    }

    public Set<Player> getTeam2() {
        return this.team2;
    }

}
