package org.devnull.matchmaking.player;

import org.devnull.matchmaking.Player;

/**
 * <p>
 * {@code PlayerWithNameBasedEquality} is a decorator for
 * {@link org.devnull.matchmaking.Player} objects.
 * </p>
 * <p>
 * Sometimes, we want to store {@code Player} objects into a
 * {@link java.util.Set}, and check duplicates only by the "name" field (assumed
 * to be the unique identifier of {@code Player}).
 * </p>
 * <p>
 * Changing the {@code equals()} method of a concrete {@code Player}
 * implementation, like {@link org.devnull.matchmaking.player.BasicPlayer}, to
 * suit this single situation is not a solution - it breaks every other usage!
 * </p>
 * <p>
 * Using a comparator, like
 * {@link org.devnull.matchmaking.player.BasicPlayer#NAME_COMPARATOR} to
 * customize the behavior of {@link java.util.TreeSet} is not a solution, too.
 * Since the Java Collections Framework states that "the ordering imposed by a
 * comparator should be consistent with equals", otherwise "the sorted set (or
 * sorted map) will behave 'strangely'". So, unlike C++ comparators, Java
 * comparators not involving all fields are for sorting only, but not for sorted
 * collection customization. For comparators used for that purpose, "you may
 * change the order, but equals remains equals". In order to fulfill this
 * requirement, the comparator must compare the next field if the current field
 * returns a tie, until all fields involved in determining {@code equals()} are
 * compared.
 * </p>
 * <p>
 * Using this decorator to "wrap" the {@code Player}s before adding to the
 * {@code Set} solves the problem.
 * </p>
 */
public final class PlayerWithNameBasedEquality implements Player, Comparable<PlayerWithNameBasedEquality>, java.io.Serializable {

    /** Generated by the serialver utility */
    //private static final long serialVersionUID = 7807574855911584647L;



    private final Player player;

    public PlayerWithNameBasedEquality(final Player player) {
        // The same as java.util.Objects#requireNonNull(T)
        if (player == null) throw new NullPointerException();
        this.player = player;
    }



    @Override
    public final int hashCode() {
        // The same as java.util.Objects#hash(Object...)
        return (1 * 31) + this.player.getName().hashCode();
    }

    @Override
    public final boolean equals(final Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        // Note: Do NOT use "instanceof" here
        // Java equality sucks, let's use Scala!
        // See: http://stackoverflow.com/q/12239344/142239
        if (obj.getClass() != PlayerWithNameBasedEquality.class) return false;
        final PlayerWithNameBasedEquality p = (PlayerWithNameBasedEquality) obj;
        return this.player.getName().equals(p.player.getName());
    }

    @Override
    public final String toString() {
        // TODO: Should use Apache Commons StringEscapeUtils to escape this.name here,
        //       but let's assume there are no special characters for simplicity.
        return new StringBuilder("[PlayerWithNameBasedEquality: ")
            .append(this.player.toString())
            .append("]")
            .toString();
    }



    @Override
    public final int compareTo(final PlayerWithNameBasedEquality player) {
        return this.player.getName().compareTo(player.player.getName());
    }



    //@Override
    //public PlayerProperties<Player> getPlayerProperty() {
    //    return null;
    //}

    @Override
    public final Player getRealPlayer() {
        return this.player.getRealPlayer();
    }

    @Override
    public final String getName() {
        return this.player.getName();
    }

    @Override
    public final long getWins() {
        return this.player.getWins();
    }

    @Override
    public final long getLosses() {
        return this.player.getLosses();
    }

}
