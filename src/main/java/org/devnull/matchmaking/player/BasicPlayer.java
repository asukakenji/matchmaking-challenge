package org.devnull.matchmaking.player;

//import static org.devnull.matchmaking.CommonMacros.*;

import org.devnull.matchmaking.Player;

import java.util.Comparator;

/**
 * <p>
 * Representation of a player.
 * </p>
 * <p>
 * As indicated in the challenge description, feel free to augment the BasicPlayer
 * class in any way that you feel will improve your final matchmaking solution.
 * <strong>Do NOT remove the name, wins, or losses fields.</strong> Also note
 * that if you make any of these changes, you are responsible for updating the
 * {@link SampleData} such that it provides a useful data set to exercise your
 * solution.
 * </p>
 */
public class BasicPlayer implements Player, java.io.Serializable {

    /** Generated by the serialver utility */
    //TODO: private static final long serialVersionUID = 6689837825227143065L;

    //public static final PlayerProperties<BasicPlayer> PLAYER_PROPERTIES = pps(
    //    null,
    //    pp("name", BasicPlayer::getName),
    //    pp("wins", BasicPlayer::getWins),
    //    pp("losses", BasicPlayer::getLosses),
    //    pp("winRate", BasicPlayer::getWinRate),
    //    pp("battlesFought", BasicPlayer::getBattlesFought)
    //);

    /**
     * A comparator that orders {@code BasicPlayer} objects by name.
     * Similar to {@link java.lang.String#CASE_INSENSITIVE_ORDER}.
     */
    public static final Comparator<BasicPlayer> NAME_COMPARATOR = new NameComparator();

    private static final class NameComparator implements Comparator<BasicPlayer>, java.io.Serializable {

        /** Generated by the serialver utility */
        //TODO: private static final long serialVersionUID = -4159245004824460530L;

        @Override
        public final int compare(final BasicPlayer p1, final BasicPlayer p2) {
            return p1.name.compareTo(p2.name);
        }
    }



    private final String name;
    private final long wins;
    private final long losses;

    public BasicPlayer(final String name, final long wins, final long losses) {
        // The same as java.util.Objects#requireNonNull(T)
        if (name == null) throw new NullPointerException();
        if (wins < 0) throw new IllegalArgumentException(name + " (wins: " + wins + ")");
        if (losses < 0) throw new IllegalArgumentException(name + " (losses: " + losses + ")");
        this.name = name;
        this.wins = wins;
        this.losses = losses;
    }



    @Override
    public int hashCode() {
        // The same as java.util.Objects#hash(Object...)
        return
            (
                (
                    (1 * 31) + this.name.hashCode()
                ) * 31 + ((int)(this.wins ^ (this.wins >>> 32)))
            ) * 31 + ((int)(this.losses ^ (this.losses >>> 32)));
    }

    // See: http://stackoverflow.com/q/13162188/142239
    protected final boolean equalsBasicPlayer(final BasicPlayer player) {
        return this.name.equals(player.name)
            && this.wins == player.wins
            && this.losses == player.losses;
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        // Note: Do NOT use "instanceof" here
        // Java equality sucks, let's use Scala!
        // See: http://stackoverflow.com/q/12239344/142239
        if (obj.getClass() != BasicPlayer.class) return false;
        return this.equalsBasicPlayer((BasicPlayer) obj);
    }

    @Override
    public String toString() {
        // TODO: Should use Apache Commons StringEscapeUtils to escape this.name here,
        //       but let's assume there are no special characters for simplicity.
        return new StringBuilder("[BasicPlayer: \"name\": \"")
            .append(this.name)
            .append("\", \"wins\": ")
            .append(this.wins)
            .append(", \"losses\": ")
            .append(this.losses)
            .append("]")
            .toString();
    }



    //@Override
    //public PlayerProperties<Player> getPlayerProperty() {
    //    return null;
    //}

    @Override
    public Player getRealPlayer() {
        return this;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public long getWins() {
        return this.wins;
    }

    @Override
    public long getLosses() {
        return this.losses;
    }

}
