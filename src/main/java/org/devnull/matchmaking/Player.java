package org.devnull.matchmaking;

import java.util.Comparator;

/**
 * <p>
 * Representation of a player.
 * </p>
 * <p>
 * As indicated in the challenge description, feel free to augment the Player
 * class in any way that you feel will improve your final matchmaking solution.
 * <strong>Do NOT remove the name, wins, or losses fields.</strong> Also note
 * that if you make any of these changes, you are responsible for updating the
 * {@link SampleData} such that it provides a useful data set to exercise your
 * solution.
 * </p>
 */
public class Player implements PlayerInterface, java.io.Serializable {

    /** Generated by the serialver utility */
    //TODO: private static final long serialVersionUID = 6767373972869040494L;

    public static final Comparator<Player> NAME_COMPARATOR = new NameComparator();

    private static final class NameComparator implements Comparator<Player>, java.io.Serializable {

        /** Generated by the serialver utility */
        //TODO: private static final long serialVersionUID = 6662658530147184337L;

        @Override
        public final int compare(final Player p1, final Player p2) {
            return p1.name.compareTo(p2.name);
        }
    }

    private final String name;
    private final int wins;
    private final int losses;

    public Player(final String name, final int wins, final int losses) {
        // The same as java.util.Objects#requireNonNull(T)
        if (name == null) throw new NullPointerException();
        if (wins < 0) throw new IllegalArgumentException(name + " (wins: " + wins + ")");
        if (losses < 0) throw new IllegalArgumentException(name + " (losses: " + losses + ")");
        this.name = name;
        this.wins = wins;
        this.losses = losses;
    }

    // Interview Note: Java Feature - Covariant Return Type
    @Override
    public Player getRealPlayer() {
        return this;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public int getWins() {
        return this.wins;
    }

    @Override
    public int getLosses() {
        return this.losses;
    }

    @Override
    public int hashCode() {
        // The same as java.util.Objects#hash(Object...)
        /* (This should be used if the fields are `long`s instead of `int`s)
        return
            (
                (
                    (1 * 31) + this.name.hashCode()
                ) * 31 + ((int)(this.wins ^ (this.wins >>> 32)))
            ) * 31 + ((int)(this.losses ^ (this.losses >>> 32)));
        */
        return
            (
                (
                    (1 * 31) + this.name.hashCode()
                ) * 31 + this.wins
            ) * 31 + this.losses;
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        // Note: Do NOT use "instanceof" here
        // Java equality sucks, let's use Scala!
        // See: http://stackoverflow.com/q/12239344/142239
        if (obj.getClass() != Player.class) return false;
        final Player p = (Player) obj;
        return this.name.equals(p.name)
            && this.wins == p.wins
            && this.losses == p.losses;
    }

    @Override
    public String toString() {
        // TODO: Should use Apache Commons StringEscapeUtils to escape this.name here,
        //       but let's assume there are no special characters for simplicity.
        return new StringBuilder("[Player: \"name\": \"")
            .append(this.name)
            .append("\", \"wins\": ")
            .append(this.wins)
            .append(", \"losses\": ")
            .append(this.losses)
            .append("]")
            .toString();
    }


    public static final void main(final String... args) {
        // TODO: Test construction exceptions
        final Player kenji_1a = new Player("Kenji", 321, 123);
        final Player kenji_1b = new Player("Kenji", 321, 123);
        final Player kenji_2 = new Player("kenji", 321, 123);
        final Player kenji_3 = new Player("Kenji", 432, 123);
        final Player kenji_4 = new Player("Kenji", 321, 234);
        assert kenji_1a.hashCode() == kenji_1b.hashCode();
        assert kenji_1a.hashCode() != kenji_2.hashCode();
        assert kenji_1a.hashCode() != kenji_3.hashCode();
        assert kenji_1a.hashCode() != kenji_4.hashCode();
        assert kenji_1a.equals(kenji_1b);
        assert !kenji_1a.equals(kenji_2);
        assert !kenji_1a.equals(kenji_3);
        assert !kenji_1a.equals(kenji_4);
        assert kenji_1a.toString().equals("[Player: \"name\": \"Kenji\", \"wins\": 321, \"losses\": 123]");
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_1a) == 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_1b) == 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_2) < 0;
        assert NAME_COMPARATOR.compare(kenji_2, kenji_1a) > 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_3) == 0;
        assert NAME_COMPARATOR.compare(kenji_1a, kenji_4) == 0;
    }
}
